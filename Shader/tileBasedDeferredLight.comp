#version 430 core

#include "Include/CommonUBO.incl"
#include "Include/DeferredLighting.incl"
#include "Include/DeferredPassTex.incl"
#include "Include/Shadow.incl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f) writeonly uniform image2D outColor;

uniform sampler2D shadowMap[MAX_DIRECTIONAL_LIGHT_COUNT * MAX_CSM_COUNT];

#define MAX_TILE_LIGHTS 1024

shared uint maxTileDepthUintBits;
shared uint minTileDepthUintBits;
shared uint tileLightCount;
shared uint tileLightIndices[MAX_TILE_LIGHTS];

void main() 
{	
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 outputSize = imageSize(outColor);
	
	vec2 uv = (vec2(pixel_coords) + 0.5) / resolution.xy;
		
	float depth = texture(gDepthStencilTex, uv).r;
	
	if(gl_LocalInvocationIndex == 0)
	{
		maxTileDepthUintBits = 0;
		minTileDepthUintBits = 0x3F800000; // 1.f
		tileLightCount = 0;
	}	
	barrier(); // all invocation sync to this point
	memoryBarrierShared(); // writes to shared variables now visible for read
	
	// find out min/max depth
	if(depth < 1.f)
	{
		uint depthUnitBits = floatBitsToInt(depth);
		atomicMax(maxTileDepthUintBits, depthUnitBits);
		atomicMin(minTileDepthUintBits, depthUnitBits);
	}
	
	barrier();
	memoryBarrierShared();
	
	float maxTileDepth = uintBitsToFloat(maxTileDepthUintBits);
	float minTileDepth = uintBitsToFloat(minTileDepthUintBits);
		
	// skip tiles fully on skybox
	if(maxTileDepth == 1.f && minTileDepth == 1.f)
		return;
	
	// tile frustum
	vec2 halfRes = resolution.xy * 0.5;
	vec2 wh = vec2(projMat[0][0], projMat[1][1]) * halfRes;
	// top left
	vec2 tileOffset0 = (halfRes - gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
	// bottom right
	vec2 tileOffset1 = tileOffset0 - gl_WorkGroupSize.xy;
	
	// in view space, only side planes, we do near/far separately 
	vec3 frustumPlanes[4];
	frustumPlanes[0] = normalize(vec3(wh.x, 0, -tileOffset0.x));	// left
	frustumPlanes[1] = normalize(vec3(-wh.x, 0, tileOffset1.x));	// right
	frustumPlanes[2] = normalize(vec3(0, wh.y, -tileOffset0.y));	// top
	frustumPlanes[3] = normalize(vec3(0, -wh.y, tileOffset1.y));	// bottom
	float frustumNear = GetViewZFromDepth(minTileDepth, projMat);
	float frustumFar = GetViewZFromDepth(maxTileDepth, projMat);
	
	// culling, here each thread run a light
	uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
	for(uint lightIdx = gl_LocalInvocationIndex; lightIdx < localLightCount && lightIdx < MAX_TILE_LIGHTS; lightIdx += threadCount)
	{
		Light light = localLights[lightIdx];
		vec3 boundCenter = light.sphereBound.xyz;
		float boundRadius = light.sphereBound.w;
		
		// result < 0 if light sphere bound is outside any plane
		float result = min(dot(frustumPlanes[0], boundCenter) + boundRadius, 0.0) +
			min(dot(frustumPlanes[1], boundCenter) + boundRadius, 0.0) +
			min(dot(frustumPlanes[2], boundCenter) + boundRadius, 0.0) +
			min(dot(frustumPlanes[3], boundCenter) + boundRadius, 0.0);
				
		if(result == 0 &&
			boundCenter.z - frustumNear <= boundRadius &&
			frustumFar - boundCenter.z <= boundRadius)
		{
		
			// light over lap this tile
			uint tileLightListIdx = atomicAdd(tileLightCount, 1);
			tileLightIndices[tileLightListIdx] = lightIdx;
		}
	}
	
	barrier();
	memoryBarrierShared();
	
#if 0
	// color code for light count
	vec3 colorCode = vec3(0,0,0);
	if(tileLightCount == 1)
		colorCode = vec3(1,0,0);
	else if(tileLightCount == 2)
		colorCode = vec3(0,1,0);
	else if(tileLightCount == 3)
		colorCode = vec3(0,0,1);
	else if(tileLightCount == 4)
		colorCode = vec3(1,1,0);
	else if(tileLightCount > 4)
		colorCode = vec3(1,0,1);
		
	imageStore(outColor, pixel_coords, vec4(colorCode, 0.0));
	return;
#endif
	
	//imageStore(outColor, pixel_coords, vec4(vec3(GetLinearDepth(minTileDepth, resolution.z, resolution.w)), 0.0));
	
	// lighting
	if(depth < 1 && pixel_coords.x < outputSize.x && pixel_coords.y < outputSize.y)
	{
		vec3 lightingResult = vec3(0);
		vec3 positionVS = vec3((uv * 2.0 - 1.0) / vec2(projMat[0][0], projMat[1][1]), -1);
		vec3 normal = normalize(texture(gNormalTex, uv).rgb * 2.0f - 1.0f);
		vec3 position = GetPositionVSFromDepth(depth, projMat, positionVS);
		vec3 view = normalize(-position);
		vec4 albedo = texture(gAlbedoTex, uv);
		vec4 material = texture(gMaterialTex, uv);
		float metallic = material.r;
		float roughness = material.g;
		float ao = material.a;
		
		// global lights
		vec3 ambient = albedo.rgb * (0.035 * (1-ao));
		lightingResult = ambient;
		int shadowCount = 0;
		for(int i = 0; i < globalLightCount; ++i)
		{
			float shadowFactor = 1;
			int shadowDataCount = globalLights[i].shadowParamA;
			for(int c = 0; c < shadowDataCount; ++c)
			{
				if(-position.z <= globalShadowData[shadowCount+c].bounds.z)
				{
					shadowFactor = CalcShadow(position, normal, -globalLights[i].directionRAB.xyz, globalShadowData[shadowCount+c].shadowMat, shadowMap[shadowCount+c], 0.0025, 0.002);
					break;
				}
			}
			shadowCount += shadowDataCount;
			lightingResult += CalcLight(globalLights[i], normal, position, view, albedo.rgb, metallic, roughness) * min(shadowFactor, 1-ao);
		}
		
		// local lights
		uint affectedLocalLightCount = tileLightCount;
		for(uint i = 0; i < affectedLocalLightCount; ++i)
		{
			uint lightIdx = tileLightIndices[i];
			Light light = localLights[lightIdx];
			
			float shadowFactor = 1;
			vec3 localLightResult = CalcLight(light, normal, position, view, albedo.rgb, metallic, roughness);
			int shadowParamA = light.shadowParamA;
			if(light.shadowParamA >= 0)
			{
				mat4 shadowMat = localLightsShadowMatrices[light.shadowParamA];
				vec3 lightDir = normalize(light.positionInvR.xyz - position);
				if(light.attenParams.y > 0.5f)
				{
					// spot light
					shadowFactor = CalcShadow(position, normal, lightDir, shadowMat, gShadowTiledTex, 0.00015, 0.0001);
				}
				else if(light.shadowParamB >= 0)
				{
					// point light cube map
					shadowFactor = CalcShadowCubeArray(position, normal, lightDir, 
						localLightsShadowMatrices[light.shadowParamA + 1], 
						shadowMat, gShadowCubeTexArray, light.shadowParamB, 0.0002, 0.0003);
				}
				else
				{
					// point light tetrahedron map
					vec4 posLVS = shadowMat * vec4(position, 1.f);
					int faceIndex = GetTetrahedronIndex(posLVS);
					shadowFactor = CalcShadowTetrahedronSingle(posLVS, normal, lightDir, 
						localLightsShadowMatrices[light.shadowParamA + 1 + faceIndex], 
						shadowMat, gShadowTiledTex, 0.00025, 0.0004);
				}
			}
			
			lightingResult += localLightResult * min(shadowFactor, 1-ao);
		}
	
		//vec2 localUV = vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy);
	
	
		imageStore(outColor, pixel_coords, vec4(lightingResult, 0.0));
	}
}